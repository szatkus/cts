{"version":3,"sources":["../../src/framework/fixture.ts"],"names":["SkipTestCase","Error","Fixture","constructor","rec","params","init","debug","msg","skip","finalize","numOutstandingAsyncExpectations","Promise","all","eventualExpectations","warn","fail","immediateAsyncExpectation","fn","ret","eventualAsyncExpectation","promise","push","expectErrorValue","expectedName","ex","niceStack","message","actualName","name","shouldReject","p","m","shouldThrow","expect","cond"],"mappings":"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","sourcesContent":["import { TestCaseRecorder } from './logger.js';\nimport { ParamSpec } from './params/index.js';\n\nexport class SkipTestCase extends Error {}\n\n// A Fixture is a class used to instantiate each test case at run time.\n// A new instance of the Fixture is created for every single test case\n// (i.e. every time the test function is run).\nexport class Fixture {\n  params: ParamSpec;\n  protected rec: TestCaseRecorder;\n  private eventualExpectations: Array<Promise<unknown>> = [];\n  private numOutstandingAsyncExpectations = 0;\n\n  constructor(rec: TestCaseRecorder, params: ParamSpec) {\n    this.rec = rec;\n    this.params = params;\n  }\n\n  // This has to be a member function instead of an async `createFixture` function, because\n  // we need to be able to ergonomically override it in subclasses.\n  async init(): Promise<void> {}\n\n  debug(msg: string): void {\n    this.rec.debug(new Error(msg));\n  }\n\n  skip(msg: string): never {\n    throw new SkipTestCase(msg);\n  }\n\n  async finalize(): Promise<void> {\n    if (this.numOutstandingAsyncExpectations !== 0) {\n      throw new Error(\n        'there were outstanding asynchronous expectations (e.g. shouldReject) at the end of the test'\n      );\n    }\n\n    await Promise.all(this.eventualExpectations);\n  }\n\n  warn(msg?: string): void {\n    this.rec.warn(new Error(msg));\n  }\n\n  fail(msg?: string): void {\n    this.rec.fail(new Error(msg));\n  }\n\n  protected async immediateAsyncExpectation<T>(fn: () => Promise<T>): Promise<T> {\n    this.numOutstandingAsyncExpectations++;\n    const ret = await fn();\n    this.numOutstandingAsyncExpectations--;\n    return ret;\n  }\n\n  protected eventualAsyncExpectation<T>(fn: (niceStack: Error) => Promise<T>): Promise<T> {\n    const promise = fn(new Error());\n    this.eventualExpectations.push(promise);\n    return promise;\n  }\n\n  private expectErrorValue(expectedName: string, ex: unknown, niceStack: Error): void {\n    if (!(ex instanceof Error)) {\n      niceStack.message = 'THREW non-error value, of type ' + typeof ex + niceStack.message;\n      this.rec.fail(niceStack);\n      return;\n    }\n    const actualName = ex.name;\n    if (actualName !== expectedName) {\n      niceStack.message = `THREW ${actualName}, instead of ${expectedName}` + niceStack.message;\n      this.rec.fail(niceStack);\n    } else {\n      niceStack.message = 'OK: threw ' + actualName + niceStack.message;\n      this.rec.debug(niceStack);\n    }\n  }\n\n  shouldReject(expectedName: string, p: Promise<unknown>, msg?: string): void {\n    this.eventualAsyncExpectation(async niceStack => {\n      const m = msg ? ': ' + msg : '';\n      try {\n        await p;\n        niceStack.message = 'DID NOT THROW' + m;\n        this.rec.fail(niceStack);\n      } catch (ex) {\n        niceStack.message = m;\n        this.expectErrorValue(expectedName, ex, niceStack);\n      }\n    });\n  }\n\n  shouldThrow(expectedName: string, fn: () => void, msg?: string): void {\n    const m = msg ? ': ' + msg : '';\n    try {\n      fn();\n      this.rec.fail(new Error('DID NOT THROW' + m));\n    } catch (ex) {\n      this.expectErrorValue(expectedName, ex, new Error(m));\n    }\n  }\n\n  expect(cond: boolean, msg?: string): boolean {\n    if (cond) {\n      const m = msg ? ': ' + msg : '';\n      this.rec.debug(new Error('expect OK' + m));\n    } else {\n      this.rec.fail(new Error(msg));\n    }\n    return cond;\n  }\n}\n"],"file":"fixture.js"}