{"version":3,"sources":["../../src/framework/test_group.ts"],"names":["allowedTestNameCharacters","paramsEquals","checkPublicParamType","extractPublicParams","validNames","RegExp","TestGroup","constructor","fixture","Set","iterate","log","test","tests","checkName","name","Error","decodeURIComponent","seen","has","add","fn","indexOf","replace","Test","push","params","specs","cases","Array","from","spec","publicParams","v","Object","values","some","x","rec","RunCaseSpecific","recorder","id","run","debug","res","record","start","inst","init","finalize","ex","threw","finish","injectResult","result","assign"],"mappings":"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","sourcesContent":["import { allowedTestNameCharacters } from './allowed_characters.js';\nimport { Fixture } from './fixture.js';\nimport { TestCaseID } from './id.js';\nimport { LiveTestCaseResult, TestCaseRecorder, TestSpecRecorder } from './logger.js';\nimport { ParamSpec, ParamSpecIterable, paramsEquals } from './params/index.js';\nimport { checkPublicParamType, extractPublicParams } from './url_query.js';\n\nexport interface RunCase {\n  readonly id: TestCaseID;\n  run(debug?: boolean): Promise<LiveTestCaseResult>;\n  injectResult(result: LiveTestCaseResult): void;\n}\n\nexport interface RunCaseIterable {\n  iterate(rec: TestSpecRecorder): Iterable<RunCase>;\n}\n\ntype FixtureClass<F extends Fixture> = new (log: TestCaseRecorder, params: ParamSpec) => F;\ntype TestFn<F extends Fixture> = (t: F) => Promise<void> | void;\n\nconst validNames = new RegExp('^[' + allowedTestNameCharacters + ']+$');\n\nexport class TestGroup<F extends Fixture> implements RunCaseIterable {\n  private fixture: FixtureClass<F>;\n  private seen: Set<string> = new Set();\n  private tests: Array<Test<F>> = [];\n\n  constructor(fixture: FixtureClass<F>) {\n    this.fixture = fixture;\n  }\n\n  *iterate(log: TestSpecRecorder): Iterable<RunCase> {\n    for (const test of this.tests) {\n      yield* test.iterate(log);\n    }\n  }\n\n  private checkName(name: string): void {\n    if (!validNames.test(name)) {\n      throw new Error(`Invalid test name ${name}; must match [${validNames}]+`);\n    }\n    if (name !== decodeURIComponent(name)) {\n      // Shouldn't happen due to the rule above. Just makes sure that treated\n      // unencoded strings as encoded strings is OK.\n      throw new Error(`Not decodeURIComponent-idempotent: ${name} !== ${decodeURIComponent(name)}`);\n    }\n\n    if (this.seen.has(name)) {\n      throw new Error(`Duplicate test name: ${name}`);\n    }\n    this.seen.add(name);\n  }\n\n  // TODO: This could take a fixture, too, to override the one for the group.\n  test(name: string, fn: TestFn<F>): Test<F> {\n    // Replace spaces with underscores for readability.\n    if (name.indexOf('_') !== -1) {\n      throw new Error('Invalid test name ${name}: contains underscore (use space)');\n    }\n    name = name.replace(/ /g, '_');\n\n    this.checkName(name);\n\n    const test = new Test<F>(name, this.fixture, fn);\n    this.tests.push(test);\n    return test;\n  }\n}\n\n// This test is created when it's inserted, but may be parameterized afterward (.params()).\nclass Test<F extends Fixture> {\n  readonly name: string;\n  readonly fixture: FixtureClass<F>;\n  readonly fn: TestFn<F>;\n  private cases: ParamSpecIterable | null = null;\n\n  constructor(name: string, fixture: FixtureClass<F>, fn: TestFn<F>) {\n    this.name = name;\n    this.fixture = fixture;\n    this.fn = fn;\n  }\n\n  params(specs: ParamSpecIterable): void {\n    if (this.cases !== null) {\n      throw new Error('test case is already parameterized');\n    }\n    const cases = Array.from(specs);\n    const seen: ParamSpec[] = [];\n    // This is n^2.\n    for (const spec of cases) {\n      const publicParams = extractPublicParams(spec);\n\n      // Check type of public params: can only be (currently):\n      // number, string, boolean, undefined, number[]\n      for (const v of Object.values(publicParams)) {\n        checkPublicParamType(v);\n      }\n\n      if (seen.some(x => paramsEquals(x, publicParams))) {\n        throw new Error('Duplicate test case params');\n      }\n      seen.push(publicParams);\n    }\n    this.cases = cases;\n  }\n\n  *iterate(rec: TestSpecRecorder): IterableIterator<RunCase> {\n    for (const params of this.cases || [null]) {\n      yield new RunCaseSpecific(rec, this.name, params, this.fixture, this.fn);\n    }\n  }\n}\n\nclass RunCaseSpecific<F extends Fixture> implements RunCase {\n  readonly id: TestCaseID;\n  private readonly params: ParamSpec | null;\n  private readonly recorder: TestSpecRecorder;\n  private readonly fixture: FixtureClass<F>;\n  private readonly fn: TestFn<F>;\n\n  constructor(\n    recorder: TestSpecRecorder,\n    test: string,\n    params: ParamSpec | null,\n    fixture: FixtureClass<F>,\n    fn: TestFn<F>\n  ) {\n    this.id = { test, params: params ? extractPublicParams(params) : null };\n    this.params = params;\n    this.recorder = recorder;\n    this.fixture = fixture;\n    this.fn = fn;\n  }\n\n  async run(debug: boolean): Promise<LiveTestCaseResult> {\n    const [rec, res] = this.recorder.record(this.id.test, this.id.params);\n    rec.start(debug);\n\n    try {\n      const inst = new this.fixture(rec, this.params || {});\n\n      try {\n        await inst.init();\n        await this.fn(inst);\n      } finally {\n        // Runs as long as constructor succeeded, even if initialization or the test failed.\n        await inst.finalize();\n      }\n    } catch (ex) {\n      // There was an exception from constructor, init, test, or finalize.\n      // An error from init or test may have been a SkipTestCase.\n      // An error from finalize may have been an eventualAsyncExpectation failure.\n      rec.threw(ex);\n    }\n\n    rec.finish();\n    return res;\n  }\n\n  injectResult(result: LiveTestCaseResult): void {\n    const [, res] = this.recorder.record(this.id.test, this.id.params);\n    Object.assign(res, result);\n  }\n}\n"],"file":"test_group.js"}