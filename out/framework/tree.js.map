{"version":3,"sources":["../../src/framework/tree.ts"],"names":["iteratePath","path","terminator","parts","split","length","partial","i","treeFromFilterResults","log","listing","insertOrNew","n","k","children","has","get","v","Map","set","tree","f","files","id","suite","description","spec","tests","trim","tRec","record","fId","t","g","iterate","cases","test","p","params","JSON","stringify","runCase"],"mappings":"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","sourcesContent":["import { Logger } from './logger.js';\nimport { TestFilterResult } from './test_filter/index.js';\nimport { RunCase } from './test_group.js';\n\nexport interface FilterResultTreeNode {\n  description?: string;\n  runCase?: RunCase;\n  children?: Map<string, FilterResultTreeNode>;\n}\n\n// e.g. iteratePath('a/b/c/d', ':') yields ['a/', 'a/b/', 'a/b/c/', 'a/b/c/d:']\nfunction* iteratePath(path: string, terminator: string): IterableIterator<string> {\n  const parts = path.split('/');\n  if (parts.length > 1) {\n    let partial = parts[0] + '/';\n    yield partial;\n    for (let i = 1; i < parts.length - 1; ++i) {\n      partial += parts[i] + '/';\n      yield partial;\n    }\n    // Path ends in '/' (so is a README).\n    if (parts[parts.length - 1] === '') {\n      return;\n    }\n  }\n  yield path + terminator;\n}\n\nexport function treeFromFilterResults(\n  log: Logger,\n  listing: IterableIterator<TestFilterResult>\n): FilterResultTreeNode {\n  function insertOrNew(n: FilterResultTreeNode, k: string): FilterResultTreeNode {\n    const children = n.children!;\n    if (children.has(k)) {\n      return children.get(k) as FilterResultTreeNode;\n    }\n    const v = { children: new Map() };\n    children.set(k, v);\n    return v;\n  }\n\n  const tree = { children: new Map() };\n  for (const f of listing) {\n    const files = insertOrNew(tree, f.id.suite + ':');\n    if (f.id.path === '') {\n      // This is a suite README.\n      files.description = f.spec.description;\n      continue;\n    }\n\n    let tests = files;\n    for (const path of iteratePath(f.id.path, ':')) {\n      tests = insertOrNew(tests, f.id.suite + ':' + path);\n    }\n    if (f.spec.description) {\n      // This is a directory README or spec file.\n      tests.description = f.spec.description.trim();\n    }\n\n    if (!('g' in f.spec)) {\n      // This is a directory README.\n      continue;\n    }\n\n    const [tRec] = log.record(f.id);\n    const fId = f.id.suite + ':' + f.id.path;\n    for (const t of f.spec.g.iterate(tRec)) {\n      let cases = tests;\n      for (const path of iteratePath(t.id.test, '~')) {\n        cases = insertOrNew(cases, fId + ':' + path);\n      }\n\n      const p = t.id.params ? JSON.stringify(t.id.params) : '';\n      cases.children!.set(fId + ':' + t.id.test + '=' + p, {\n        runCase: t,\n      });\n    }\n  }\n  return tree;\n}\n"],"file":"tree.js"}