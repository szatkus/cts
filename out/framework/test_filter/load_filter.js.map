{"version":3,"sources":["../../../src/framework/test_filter/load_filter.ts"],"names":["allowedTestNameCharacters","FilterByGroup","FilterByParamsExact","FilterByParamsMatch","FilterByTestMatch","loadFilter","loader","filter","i1","indexOf","Error","suite","substring","i2","groupPrefix","iterate","path","endOfTestName","RegExp","i3sub","search","testPrefix","i3","test","token","charAt","params","length","JSON","parse"],"mappings":";;;;AAAA,SAASA,yBAAT,QAA0C,0BAA1C;AAIA,SAASC,aAAT,QAA8B,sBAA9B;AACA,SAASC,mBAAT,EAA8BC,mBAA9B,EAAmDC,iBAAnD,QAA4E,sBAA5E;AAGA;AACA,OAAO,eAAeC,UAAf,CACLC,MADK,EAELC,MAFK,EAGwB;AAC7B,QAAMC,EAAE,GAAGD,MAAM,CAACE,OAAP,CAAe,GAAf,CAAX;;AACA,MAAID,EAAE,KAAK,CAAC,CAAZ,EAAe;AACb,UAAM,IAAIE,KAAJ,CAAU,gEAAV,CAAN;AACD;;AAED,QAAMC,KAAK,GAAGJ,MAAM,CAACK,SAAP,CAAiB,CAAjB,EAAoBJ,EAApB,CAAd;AACA,QAAMK,EAAE,GAAGN,MAAM,CAACE,OAAP,CAAe,GAAf,EAAoBD,EAAE,GAAG,CAAzB,CAAX;;AACA,MAAIK,EAAE,KAAK,CAAC,CAAZ,EAAe;AACb;AACA;AACA;AACA;AACA,UAAMC,WAAW,GAAGP,MAAM,CAACK,SAAP,CAAiBJ,EAAE,GAAG,CAAtB,CAApB;AACA,WAAO,IAAIP,aAAJ,CAAkBU,KAAlB,EAAyBG,WAAzB,EAAsCC,OAAtC,CAA8CT,MAA9C,CAAP;AACD;;AAED,QAAMU,IAAI,GAAGT,MAAM,CAACK,SAAP,CAAiBJ,EAAE,GAAG,CAAtB,EAAyBK,EAAzB,CAAb;AACA,QAAMI,aAAa,GAAG,IAAIC,MAAJ,CAAW,OAAOlB,yBAAP,GAAmC,GAA9C,CAAtB;AACA,QAAMmB,KAAK,GAAGZ,MAAM,CAACK,SAAP,CAAiBC,EAAE,GAAG,CAAtB,EAAyBO,MAAzB,CAAgCH,aAAhC,CAAd;;AACA,MAAIE,KAAK,KAAK,CAAC,CAAf,EAAkB;AAChB;AACA;AACA,UAAME,UAAU,GAAGd,MAAM,CAACK,SAAP,CAAiBC,EAAE,GAAG,CAAtB,CAAnB;AACA,WAAO,IAAIT,iBAAJ,CAAsB;AAAEO,MAAAA,KAAF;AAASK,MAAAA;AAAT,KAAtB,EAAuCK,UAAvC,EAAmDN,OAAnD,CAA2DT,MAA3D,CAAP;AACD;;AAED,QAAMgB,EAAE,GAAGT,EAAE,GAAG,CAAL,GAASM,KAApB;AACA,QAAMI,IAAI,GAAGhB,MAAM,CAACK,SAAP,CAAiBC,EAAE,GAAG,CAAtB,EAAyBS,EAAzB,CAAb;AACA,QAAME,KAAK,GAAGjB,MAAM,CAACkB,MAAP,CAAcH,EAAd,CAAd;AAEA,MAAII,MAAM,GAAG,IAAb;;AACA,MAAIJ,EAAE,GAAG,CAAL,GAASf,MAAM,CAACoB,MAApB,EAA4B;AAC1BD,IAAAA,MAAM,GAAGE,IAAI,CAACC,KAAL,CAAWtB,MAAM,CAACK,SAAP,CAAiBU,EAAE,GAAG,CAAtB,CAAX,CAAT;AACD;;AAED,MAAIE,KAAK,KAAK,GAAd,EAAmB;AACjB;AACA;AACA;AACA,WAAO,IAAIrB,mBAAJ,CAAwB;AAAEQ,MAAAA,KAAF;AAASK,MAAAA;AAAT,KAAxB,EAAyCO,IAAzC,EAA+CG,MAA/C,EAAuDX,OAAvD,CAA+DT,MAA/D,CAAP;AACD,GALD,MAKO,IAAIkB,KAAK,KAAK,GAAd,EAAmB;AACxB;AACA;AACA;AACA,WAAO,IAAItB,mBAAJ,CAAwB;AAAES,MAAAA,KAAF;AAASK,MAAAA;AAAT,KAAxB,EAAyCO,IAAzC,EAA+CG,MAA/C,EAAuDX,OAAvD,CAA+DT,MAA/D,CAAP;AACD,GALM,MAKA;AACL,UAAM,IAAII,KAAJ,CAAU,uDAAV,CAAN;AACD;AACF","sourcesContent":["import { allowedTestNameCharacters } from '../allowed_characters.js';\nimport { TestFileLoader } from '../loader.js';\nimport { ParamSpec } from '../params/index.js';\n\nimport { FilterByGroup } from './filter_by_group.js';\nimport { FilterByParamsExact, FilterByParamsMatch, FilterByTestMatch } from './filter_one_file.js';\nimport { TestFilterResult } from './index.js';\n\n// Each filter is of one of the forms below (urlencoded).\nexport async function loadFilter(\n  loader: TestFileLoader,\n  filter: string\n): Promise<TestFilterResult[]> {\n  const i1 = filter.indexOf(':');\n  if (i1 === -1) {\n    throw new Error('Test queries must fully specify their suite name (e.g. \"cts:\")');\n  }\n\n  const suite = filter.substring(0, i1);\n  const i2 = filter.indexOf(':', i1 + 1);\n  if (i2 === -1) {\n    // - cts:\n    // - cts:buf\n    // - cts:buffers/\n    // - cts:buffers/map\n    const groupPrefix = filter.substring(i1 + 1);\n    return new FilterByGroup(suite, groupPrefix).iterate(loader);\n  }\n\n  const path = filter.substring(i1 + 1, i2);\n  const endOfTestName = new RegExp('[^' + allowedTestNameCharacters + ']');\n  const i3sub = filter.substring(i2 + 1).search(endOfTestName);\n  if (i3sub === -1) {\n    // - cts:buffers/mapWriteAsync:\n    // - cts:buffers/mapWriteAsync:b\n    const testPrefix = filter.substring(i2 + 1);\n    return new FilterByTestMatch({ suite, path }, testPrefix).iterate(loader);\n  }\n\n  const i3 = i2 + 1 + i3sub;\n  const test = filter.substring(i2 + 1, i3);\n  const token = filter.charAt(i3);\n\n  let params = null;\n  if (i3 + 1 < filter.length) {\n    params = JSON.parse(filter.substring(i3 + 1)) as ParamSpec;\n  }\n\n  if (token === '~') {\n    // - cts:buffers/mapWriteAsync:basic~\n    // - cts:buffers/mapWriteAsync:basic~{}\n    // - cts:buffers/mapWriteAsync:basic~{filter:\"params\"}\n    return new FilterByParamsMatch({ suite, path }, test, params).iterate(loader);\n  } else if (token === '=') {\n    // - cts:buffers/mapWriteAsync:basic=\n    // - cts:buffers/mapWriteAsync:basic={}\n    // - cts:buffers/mapWriteAsync:basic={exact:\"params\"}\n    return new FilterByParamsExact({ suite, path }, test, params).iterate(loader);\n  } else {\n    throw new Error(\"invalid character after test name; must be '~' or '='\");\n  }\n}\n"],"file":"load_filter.js"}