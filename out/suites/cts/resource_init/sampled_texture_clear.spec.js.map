{"version":3,"sources":["../../../../src/suites/cts/resource_init/sampled_texture_clear.spec.ts"],"names":["description","TestGroup","GPUTest","g","test","t","texture","device","createTexture","size","width","height","depth","format","usage","GPUTextureUsage","SAMPLED","bufferTex","createBuffer","GPUBufferUsage","COPY_SRC","STORAGE","COPY_DST","sampler","createSampler","bindGroupLayout","createBindGroupLayout","bindings","binding","visibility","GPUShaderStage","COMPUTE","type","computeModule","createShaderModule","code","pipelineLayout","createPipelineLayout","bindGroupLayouts","computePipeline","createComputePipeline","computeStage","module","entryPoint","layout","bindGroup","createBindGroup","resource","createView","buffer","offset","encoder","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatch","endPass","commands","finish","defaultQueue","submit","expectContents","Uint32Array"],"mappings":"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","sourcesContent":["export const description = `\ncomputePass test that sampled texture is cleared`;\n\nimport { TestGroup } from '../../../framework/index.js';\nimport GLSL from '../../../tools/glsl.macro.js';\nimport { GPUTest } from '../gpu_test.js';\n\nexport const g = new TestGroup(GPUTest);\n\ng.test('compute pass test that sampled texture is cleared', async t => {\n  const texture = t.device.createTexture({\n    size: { width: 256, height: 256, depth: 1 },\n    format: 'r8unorm',\n    usage: GPUTextureUsage.SAMPLED,\n  });\n\n  const bufferTex = t.device.createBuffer({\n    size: 4 * 256 * 256,\n    usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n  });\n\n  const sampler = t.device.createSampler();\n\n  const bindGroupLayout = t.device.createBindGroupLayout({\n    bindings: [\n      { binding: 0, visibility: GPUShaderStage.COMPUTE, type: 'sampled-texture' },\n      { binding: 1, visibility: GPUShaderStage.COMPUTE, type: 'storage-buffer' },\n      { binding: 2, visibility: GPUShaderStage.COMPUTE, type: 'sampler' },\n    ],\n  });\n\n  // create compute pipeline\n  const computeModule = t.device.createShaderModule({\n    code: GLSL(\n      'compute',\n      `#version 450\n      layout(binding = 0) uniform texture2D sampleTex;\n      layout(std430, binding = 1) buffer BufferTex {\n         vec4 result;\n      } bufferTex;\n      layout(binding = 2) uniform sampler sampler0;\n      void main() {\n         bufferTex.result =\n               texelFetch(sampler2D(sampleTex, sampler0), ivec2(0,0), 0);\n      }`\n    ),\n  });\n  const pipelineLayout = t.device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] });\n  const computePipeline = t.device.createComputePipeline({\n    computeStage: { module: computeModule, entryPoint: 'main' },\n    layout: pipelineLayout,\n  });\n\n  // create bindgroup\n  const bindGroup = t.device.createBindGroup({\n    layout: bindGroupLayout,\n    bindings: [\n      { binding: 0, resource: texture.createView() },\n      { binding: 1, resource: { buffer: bufferTex, offset: 0, size: 4 * 256 * 256 } },\n      { binding: 2, resource: sampler },\n    ],\n  });\n\n  // encode the pass and submit\n  const encoder = t.device.createCommandEncoder();\n  const pass = encoder.beginComputePass();\n  pass.setPipeline(computePipeline);\n  pass.setBindGroup(0, bindGroup);\n  pass.dispatch(256, 256, 1);\n  pass.endPass();\n  const commands = encoder.finish();\n  t.device.defaultQueue.submit([commands]);\n\n  await t.expectContents(bufferTex, new Uint32Array([0]));\n});\n"],"file":"sampled_texture_clear.spec.js"}