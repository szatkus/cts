{"version":3,"sources":["../../../../src/suites/cts/validation/render_pass.spec.ts"],"names":["description","TestGroup","ValidationTest","F","getUniformBuffer","device","createBuffer","size","Float32Array","BYTES_PER_ELEMENT","usage","GPUBufferUsage","UNIFORM","createRenderPipeline","pipelineLayout","vertexModule","createShaderModule","code","fragmentModule","pipeline","vertexStage","module","entryPoint","fragmentStage","layout","primitiveTopology","colorStates","format","beginRenderPass","commandEncoder","attachmentTexture","createTexture","width","height","depth","GPUTextureUsage","OUTPUT_ATTACHMENT","colorAttachments","attachment","createView","loadValue","r","g","b","a","test","t","setBindGroup1","setBindGroup2","_success","params","uniformBuffer","bindGroupLayout1","createBindGroupLayout","bindings","binding","visibility","GPUShaderStage","VERTEX","type","bindGroup1","createBindGroup","resource","buffer","bindGroupLayout2","FRAGMENT","bindGroup2","createPipelineLayout","bindGroupLayouts","createCommandEncoder","renderPass","setPipeline","setBindGroup","draw","endPass","expectValidationError","finish"],"mappings":"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","sourcesContent":["export const description = `\nrender pass validation tests.\n`;\n\nimport { TestGroup } from '../../../framework/index.js';\nimport GLSL from '../../../tools/glsl.macro.js';\n\nimport { ValidationTest } from './validation_test.js';\n\nclass F extends ValidationTest {\n  getUniformBuffer(): GPUBuffer {\n    return this.device.createBuffer({\n      size: 4 * Float32Array.BYTES_PER_ELEMENT,\n      usage: GPUBufferUsage.UNIFORM,\n    });\n  }\n\n  createRenderPipeline(pipelineLayout: GPUPipelineLayout): GPURenderPipeline {\n    const vertexModule = this.createShaderModule({\n      code: GLSL(\n        'vertex',\n        `#version 450\n          layout (set = 0, binding = 0) uniform vertexUniformBuffer {\n              mat2 transform;\n          };\n          void main() {\n              const vec2 pos[3] = vec2[3](vec2(-1.f, -1.f), vec2(1.f, -1.f), vec2(-1.f, 1.f));\n              gl_Position = vec4(transform * pos[gl_VertexIndex], 0.f, 1.f);\n          }\n        `\n      ),\n    });\n\n    const fragmentModule = this.createShaderModule({\n      code: GLSL(\n        'fragment',\n        `#version 450\n          layout (set = 1, binding = 0) uniform fragmentUniformBuffer {\n            vec4 color;\n          };\n          layout(location = 0) out vec4 fragColor;\n          void main() {\n          }\n        `\n      ),\n    });\n\n    const pipeline = this.device.createRenderPipeline({\n      vertexStage: { module: vertexModule, entryPoint: 'main' },\n      fragmentStage: { module: fragmentModule, entryPoint: 'main' },\n      layout: pipelineLayout,\n      primitiveTopology: 'triangle-list',\n      colorStates: [{ format: 'rgba8unorm' }],\n    });\n    return pipeline;\n  }\n\n  beginRenderPass(commandEncoder: GPUCommandEncoder): GPURenderPassEncoder {\n    const attachmentTexture = this.device.createTexture({\n      format: 'rgba8unorm',\n      size: { width: 16, height: 16, depth: 1 },\n      usage: GPUTextureUsage.OUTPUT_ATTACHMENT,\n    });\n\n    return commandEncoder.beginRenderPass({\n      colorAttachments: [\n        {\n          attachment: attachmentTexture.createView(),\n          loadValue: { r: 1.0, g: 0.0, b: 0.0, a: 1.0 },\n        },\n      ],\n    });\n  }\n}\n\nexport const g = new TestGroup(F);\n\ng.test('it is invalid to draw in a render pass with missing bind groups', async t => {\n  const { setBindGroup1, setBindGroup2, _success } = t.params;\n\n  const uniformBuffer = t.getUniformBuffer();\n\n  const bindGroupLayout1 = t.device.createBindGroupLayout({\n    bindings: [\n      {\n        binding: 0,\n        visibility: GPUShaderStage.VERTEX,\n        type: 'uniform-buffer',\n      },\n    ],\n  });\n\n  const bindGroup1 = t.device.createBindGroup({\n    bindings: [\n      {\n        binding: 0,\n        resource: {\n          buffer: uniformBuffer,\n        },\n      },\n    ],\n    layout: bindGroupLayout1,\n  });\n\n  const bindGroupLayout2 = t.device.createBindGroupLayout({\n    bindings: [\n      {\n        binding: 0,\n        visibility: GPUShaderStage.FRAGMENT,\n        type: 'uniform-buffer',\n      },\n    ],\n  });\n\n  const bindGroup2 = t.device.createBindGroup({\n    bindings: [\n      {\n        binding: 0,\n        resource: {\n          buffer: uniformBuffer,\n        },\n      },\n    ],\n    layout: bindGroupLayout2,\n  });\n\n  const pipelineLayout = t.device.createPipelineLayout({\n    bindGroupLayouts: [bindGroupLayout1, bindGroupLayout2],\n  });\n\n  const pipeline = t.createRenderPipeline(pipelineLayout);\n\n  const commandEncoder = t.device.createCommandEncoder();\n  const renderPass = t.beginRenderPass(commandEncoder);\n  renderPass.setPipeline(pipeline);\n  if (setBindGroup1) {\n    renderPass.setBindGroup(0, bindGroup1);\n  }\n  if (setBindGroup2) {\n    renderPass.setBindGroup(1, bindGroup2);\n  }\n  renderPass.draw(3, 1, 0, 0);\n  renderPass.endPass();\n  t.expectValidationError(() => {\n    commandEncoder.finish();\n  }, !_success);\n}).params([\n  { setBindGroup1: true, setBindGroup2: true, _success: true },\n  { setBindGroup1: true, setBindGroup2: false, _success: false },\n  { setBindGroup1: false, setBindGroup2: true, _success: false },\n  { setBindGroup1: false, setBindGroup2: false, _success: false },\n]);\n"],"file":"render_pass.spec.js"}